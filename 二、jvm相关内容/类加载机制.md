# 一、类加载

![image-20191216101701063](C:\Users\l\AppData\Roaming\Typora\typora-user-images\image-20191216101701063.png)

加载、验证、准备、初始化、卸载五个阶段的顺序是确定的，解析截断不一定，在某些情况下可以在初始化之后，比如动态绑定。

```tex
被动引用：
	1.子类引用父类的静态字段，不会导致子类初始化
    2.通过数组定义来引用类，不会触发此类的初始化
    3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
```



## 1.1、加载

```
 通过一个类的全限定名来获取定义此类的二进制字节流
​ 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。
​ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段与连接阶段是交叉进行的，可能加载阶段尚未完成，连接阶段已经开始。开始时间的先后顺序是固定的
```

##  1.2、验证

a)文件格式验证：**Class文件格式的规范**

```
 是否以魔术0XCAFEBABE开头。
​ 主、次版本号是否在当前虚拟机处理范围之内。
​ 常量池的常量中是否有不被支持的常量类型
​ 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的         常量
​ CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据
​ Class文件中各个部分及文件本身是否有被删除的或附加的其他信息

基于二进制字节流进行，通过这个验证，字节流才会进入内存的方法区进行存储，后面的三个验证都是基于方法区的存储结构进行的。
```

b)元数据验证：**对字节码描述的信息语义分析校验**

```
 这个是否有父类（除了Object之外）
​ 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
​ 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的方法
​ 类中的字段、方法是否与父类产生矛盾
```

c)字节码验证：**对方法体验证程序语义是合法、符合逻辑的**

```
 任意时刻操作栈中的数据类型与指令代码序列配合工作
​ 保证跳转指令不会跳转到方法体以外的字节码指令上
​ 类型转换有效
```

d)符号引用验证：**对类自身以外（常量池中各种符号引用）进行校验**

```
解析阶段发生，JVM将符号引用转换为直接引用
​ 符号引用中通过字符串描述的全限定名是否能找到对应的类
​ 指定的类中是否存在符合方法的字段描述符
​ 符号引用中的类、字段、方法的访问性是否可被当前类访问
```

##  1.3、准备

为**类变量**（静态变量，被static修饰的变量 ）**分配内存**(方法区内存)并设置**类变量初始值**阶段，这些变量所使用的内存都将在方法区中进行分配。初始值根据类型给定默认值，初始化阶段再赋值；如果变量被static final修饰，准备阶段就给赋值了。

##  1.4、解析

虚拟机将**常量池内**的**符号引用**替换为**直接引用**的过程。

符号引用：以一组符号描述所引用的目标

直接引用：直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。

解析动作主要针对：类或接口、字段、类方法、方法类型、接口方法、方法句柄、调用点限定符

##  1.5、初始化

初始化阶段是执行<clinit>() 方法的过程

```
 <clinit>() 方法是由编译器收集类中的：
        所有类变量的赋值动作
        静态语句块中的语句   合并产生的
     注：静态代码块中只能 访问 到定义在该代码块之前的变量，定义在之后的 能赋值，但不能访问。否则报错Illegal forward reference.
     
​ <clinit>() 方法与类构造器不同，子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。
     
```



