# 一、Java内存区域

## 1、运行时数据区域

   ![image-20191128144744377](C:\Users\l\AppData\Roaming\Typora\typora-user-images\image-20191128144744377.png)

### 1.1、程序计数器

​		程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

 		每个线程都需要一个独立的程序计数器。因为Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。各条线程之间计数器互不影响，独立存储，是线程私有的内存。

​		如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程正在执行native方法，则计数器的值为空（Undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

```tex
总结：1.字节码解释器通过改变计数器的值读取指令，从而实现流程控制，如顺        序执行、循环、跳转、异常处理等。
	 2.多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程        被切换回来的时候能够知道该线程上次运行到哪儿。
```



### 1.2、Java虚拟机栈

​		Java虚拟机栈也是线程私有的，它的生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

​		Java内存粗糙的区分为堆内存和栈内存，其中栈就是现在说的虚拟机栈，或者说的是虚拟机栈中局部变量表部分。

​		局部变量表主要存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它不等同于对象本身，，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型(指向了一条字节码指令的地址)。

​		局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

​		Java虚拟机栈会出现两种异常：

				1. StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度。
   				2. OutOfMemoryError异常：虚拟机动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

![image-20191128173008727](C:\Users\l\AppData\Roaming\Typora\typora-user-images\image-20191128173008727.png)

```tex
总结：1.每次方法调用的数据通过栈传递的（每个方法在执行的同时创建一个栈帧，方法调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈帧存储了局部变量表、操作数、动态链接、方法出口等）。
     2.局部变量表主要存放了编译器可知的各种数据类型、对象引用。
     3.Java虚拟机栈会出现两种异常。
```



### 1.3、本地方法栈

​	http://dy.163.com/v2/article/detail/EBV0AOO3054479O4.html



书P40页……………………………………………………