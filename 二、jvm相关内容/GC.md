# 一、GC

## 1、对象是否存活

### 		1.1、引用计数算法

​				给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器减1，任何时刻计数器为0的对象就是不可能再被使用的。（当两个对象相互引用，计数器的值不为0，但这两个对象已经不可能再被访问，但是GC不会回收，所以JVM不是通过引用计数算法来判断对象是否存活。）



### 		1.2、可达性算法

​				通过一系列称为"GC Root"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连（到GC Root不可达）,证明对象不可用。

​				在Java中，可作为GC Root的对象包括下面几种：

​           **·** 虚拟机栈（栈帧中的本地变量表）中引用的对象。

​           **·** 方法区中静态属性引用的对象。

​           **·** 方法区中常量引用 的对象。 

​           **·** 本地方法栈中JNI（Java Native Interface)引用的对象。

## 2、垃圾收集算法

### 	2.1、标记-清除算法

```
首先先标记出需要清除的对象，标记完成后统一清除。
不足：
​ 时间上：标记和清除两个过程，效率不高；

​ 空间上：产生大量不连续内存碎片。
```

### 	2.2、复制算法

```tex
堆中内存划分为Eden、S0、S1。每次使用Eden和其中一块，S0和S1容量大小相同。新创建对象放Eden区，经过一轮GC，存活的对象复制到另一块区域，最后清理掉Eden和刚才用过的S区。
不足：
​ 当对象存活率较高时进行复制操作较多，效率会低。
```

### 	2.3、标记-整理算法

```tex
先进行标记需要清理的对象，将存活对象都移动到一端，然后清理端边以外的内存。
```

### 	2.4、分代收集算法

```tex
根据对象存活周期不同将堆分为新生代和老年代。新生代中对象存活率低，使用复制算法，老年代中对象存活率高，使用标记-清除或标记-整理。
```



## 3、垃圾收集器

### 3.1、Serial收集器

单线程的收集器，进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

![image-20191212143717296](C:\Users\l\AppData\Roaming\Typora\typora-user-images\image-20191212143717296.png)

### 3.2、ParNew收集器

Serial收集器的多线程版本。

![image-20191212150138605](C:\Users\l\AppData\Roaming\Typora\typora-user-images\image-20191212150138605.png)

### 3.3、Parallel Scavenge收集器

新生代收集器，使用复制算法，并行的多线程收集器，

<u>并行</u>：垃圾收集线程并行执行，用户线程仍然处于等待状态。

<u>并发</u>：用户线程和垃圾收集线程同时执行，用户程序在继续运行，而垃圾收集在另一个cpu上运行

<u>吞吐量</u>：CPU用于运行用户代码的时间与CPU总消耗时间的比值。

即：吞吐量=运行用户代码需要时间/(运行用户代码需要时间+垃圾收集时间)

### 3.4、CMS收集器

过程：初始标记、并发标记、重新标记、并发清除

获取最短回收停顿时间为目标，标记-清除算法，并发收集，低停顿。

缺点：

​       对CPU资源非常敏感，在并发阶段，它占用一部分线程而导致程序变慢，总吞吐量会降低。

​       无法处理浮动垃圾，并发清理截断用户线程还在运行，会产生新的垃圾，只能留到下一次GC清理。

​         标记-清除算法，产生大量内存碎片，会给大对象分配带来麻烦。







